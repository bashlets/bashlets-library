#!/bin/bash


################################################################################
#                                         
# |              |    |         |         
# |---.,---.,---.|---.|    ,---.|--- ,---.
# |   |,---|`---.|   ||    |---'|    `---.
# `---'`---^`---'`   '`---'`---'`---'`---'
#
#                                        
# Bashlets -- A modular extensible toolbox for Bash
#
# Copyright (c) 2014-6 Roberto Reale
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
################################################################################

#@method
function bashlets_tcl_math_get_text()
{
    local f="$1"
    local tcl_text

    case "$f" in 
        e-power-series)
            tcl_text='
                #
                # approximate e using the power series expansion
                #

                proc approx_e {{n 20}} {
                    set value 1
                        set factorial 1
                        set i 1

                        while {$i <= $n} {
                            set factorial [expr {$factorial * $i}]
                                set value [expr {$value + 1.0/$factorial}]
                                incr i
                        }

                    return $value
                }
            '
            ;;
        wallis)
            tcl_text="
                #
                # approximate PI with the aid of Wallis' product
                #

                proc wallis {{n 1000000}} {
                    set value 1.0
                    set i 1
                    
                    while {\$i < \$n} {
                        set i2 [expr {(\$i*2)**2}]

                        set value [expr {\$value * \$i2 / (\$i2-1)}]
                        incr i
                    }
                    
                    return \$value
                }
            "
            ;;
        chebyshev)
            tcl_text='
                #
                # recursively calculate Chebyshev polynomials
                #
                #   (see http://en.wikipedia.org/wiki/Chebyshev_polynomials)
                #

                # we need Tcl 8.5 for lrepeat to be defined
                package require Tcl 8.5

                proc min {x y} {
                    if {$x <= $y} {return $x} {return $y}
                }

                #
                # NOTE: polynomials are represented as lists, e.g. the polynomial 2x^3 + 3x + 1
                #       is represented as [1, 3, 0, 2]
                #

                #
                # trim out zero term of higher degrees, e.g. 0x^4 + x^3 + 1 => x^3 + 1
                #
                proc poly_trim {p} {
                    for {set i [expr {[llength $p] - 1}]} {$i >= 0} {set i [expr {$i - 1}]} {
                        if {[lindex $p $i] == 0} {
                            set p [lreplace $p end end]
                        } else {
                            break
                        }
                    }
                    
                    return $p
                }

                #
                # add two polynomials
                #
                proc poly_add {p q} {
                    set m [min [llength $p] [llength $q]]
                    set sum [list]
                    
                    for {set i 0} {$i < $m} {incr i} {
                        lappend sum [expr {[lindex $p $i] + [lindex $q $i]}]
                    }
                    
                    if {[llength $p] > [llength $q]} {
                        for {set i $m} {$i < [llength $p]} {incr i} {
                            lappend sum [lindex $p $i]
                        }
                    } elseif {[llength $p] < [llength $q]} {
                        for {set i $m} {$i < [llength $q]} {incr i} {
                            lappend sum [lindex $q $i]
                        }
                    }

                    return [poly_trim $sum]
                }

                #
                # multiply two polynomials
                #
                proc poly_multiply {p q} {
                    set product [lrepeat [expr {[llength $p] + [llength $q] - 1}] 0]
                    
                    for {set i 0} {$i < [llength $p]} {incr i} {
                        for {set j 0} {$j < [llength $q]} {incr j} {
                            set k [expr {$i + $j}]

                            set product [
                                lreplace $product $k $k [
                                    expr {
                                        [lindex $product $k]
                                        +
                                        [expr {[lindex $p $i] * [lindex $q $j]}]
                                    }
                                ]
                            ]
                        }
                    }
                    
                    return [poly_trim $product]
                }

                #
                # Chebyshev polynomials of the first kind
                #
                # these are defined recursively as follows:
                #
                #   T_0(x) = 1
                #   T_1(x) = x
                #   T_{n+1}(x) = 2xT_n(x) - T_{n-1}(x)
                #
                proc chebyshev1 {n} {
                    if {$n <= 0} {
                        return [list 1]
                    } elseif {$n == 1} {
                        return [list 0 1]
                    } else {
                        return [
                            poly_add [
                                poly_multiply [list 0 2] [chebyshev1 [expr {$n - 1}]]
                            ] [
                                poly_multiply [list -1] [chebyshev1 [expr {$n - 2}]]
                            ]
                        ]
                    }
                }

                #
                # Chebyshev polynomials of the second kind
                #
                # these are defined recursively as follows:
                #
                #   U_0(x) = 1
                #   U_1(x) = 2x
                #   U_{n+1}(x) = 2xU_n(x) - U_{n-1}(x)
                #
                proc chebyshev2 {n} {
                    if {$n <= 0} {
                        return [list 1]
                    } elseif {$n == 1} {
                        return [list 0 2]
                    } else {
                        return [
                            poly_add [
                                poly_multiply [list 0 2] [chebyshev2 [expr {$n - 1}]]
                            ] [
                                poly_multiply [list -1] [chebyshev2 [expr {$n - 2}]]
                            ]
                        ]
                    }
                }
            '
            ;;
        *)
            # TODO error!
            ;;
    esac

    cat <<< "$tcl_text"
}


#@method
function bashlets_tcl_math_e_power_series()
{
    local iterations=${1:-20}
    local tcl_text

    tcl_text="
        $(bashlets_tcl_math_get_text e-power-series)

        puts [approx_e $iterations]
    "

    tclsh <<< "$tcl_text"
}

#@method
function bashlets_tcl_math_wallis()
{
    local iterations=${1:-1000000}
    local tcl_text

    tcl_text="
        $(bashlets_tcl_math_get_text wallis)

        puts [expr {2 * [wallis $iterations]}]
    "

    tclsh <<< "$tcl_text"
}

#@method
function bashlets_tcl_math_chebyshev1()
{
    local degree=${1:-10}
    local tcl_text

    tcl_text="
        $(bashlets_tcl_math_get_text chebyshev)

        puts [chebyshev1 $degree]
    "

    tclsh <<< "$tcl_text"
}

#@method
function bashlets_tcl_math_chebyshev2()
{
    local degree=${1:-10}
    local tcl_text

    tcl_text="
        $(bashlets_tcl_math_get_text chebyshev)

        puts [chebyshev2 $degree]
    "

    tclsh <<< "$tcl_text"
}


# Local variables:
# mode: shell-script
# sh-basic-offset: 4
# sh-indent-comment: t
# indent-tabs-mode: nil
# End:
# ex: ts=4 sw=4 et filetype=sh
